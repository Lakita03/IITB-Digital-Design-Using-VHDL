library ieee;
use ieee.std_logic 1164.all;
library work;
use work.gates.all;
entity shift is 
port (1: in std_logic;
      b: in std logic vector(2 downto 0);
		data: in std_logic_vector(7 downto 0);
      output: out std_logic_vector( vector downto 0);
end entity:
architecture struct of shift is

 component muxtask is

Port(
I: in std_logic_vector(1 downto 0);
S:in std_logic
Y: out std_logic
);
end component;

signal a:std_logic_vector(7 downto 0); 
signal s1 std logic vector(7 downto 0);
signal s2: std logic_vector(7 downto 0); 
signal s3: std_logic_vector downto 0);
begin

rev :for i in 0 to 7: 
lsb:if i<8 generate

b2: muxtask port map (I(0)=>data(i), I(1)=>data(7-i), s=> 1,Y =>a(i));

end generate lsb;
 end generate rev;



n4_bit for i in 0 to 7 generate
lsb1: if i<4 generate
b3: muxtask port map(I(0)=>a(i),I(1)=> a(i+4),S=>b(2),Y=>s1(i));
end generate lsb1;
msb1: if i>3 generate
b4: muxtask port map(I(0)=>a(i),I(1)=> '0',S=>b(2),Y=>s1(i));
end generate msb1;

lsb2: if i<6 generate
b5: muxtask port map(I(0)=>s1(i),I(1)=> s1(i+2),S=>b(1),Y=>s2(i));
end generate lsb2;
msb2: if i>5 generate
b6: muxtask port map(I(0)=>s1(i),I(1)=> '0',S=>b(1),Y=>s2(i));
end generate msb2;

lsb3: if i<7 generate
b7: muxtask port map(I(0)=>s2(i),I(1)=> s2(i+1),S=>b(0),Y=>s3(i));
end generate lsb3;
msb3: if i>6 generate
b8: muxtask port map(I(0)=>s2(i),I(1)=> '0',S=>b(0),Y=>s3(i));
end generate msb3;
end generate msb3;
